//  Copyright (C) 2021, Christoph Peters, Karlsruhe Institute of Technology
//
//  This program is free software: you can redistribute it and/or modify
//  it under the terms of the GNU General Public License as published by
//  the Free Software Foundation, either version 3 of the License, or
//  (at your option) any later version.
//
//  This program is distributed in the hope that it will be useful,
//  but WITHOUT ANY WARRANTY; without even the implied warranty of
//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//  GNU General Public License for more details.
//
//  You should have received a copy of the GNU General Public License
//  along with this program.  If not, see <https://www.gnu.org/licenses/>.


#pragma once
#include <stdint.h>
#include <stdio.h>
#include <string.h>
#include <math.h>

//! Pi with single precision
#include "shaders/math_constants.glsl"

//! Writes the multiplicative inverse of the given 4x4 matrix
static inline void matrix_inverse(float inverse[4][4], const float matrix[4][4]) {
	float* inv = &inverse[0][0];
	const float* m = &matrix[0][0];
	inv[ 0] =  m[5] * m[10] * m[15] - m[5] * m[11] * m[14] - m[9] * m[6] * m[15] + m[9] * m[7] * m[14] + m[13] * m[6] * m[11] - m[13] * m[7] * m[10];
	inv[ 4] = -m[4] * m[10] * m[15] + m[4] * m[11] * m[14] + m[8] * m[6] * m[15] - m[8] * m[7] * m[14] - m[12] * m[6] * m[11] + m[12] * m[7] * m[10];
	inv[ 8] =  m[4] * m[ 9] * m[15] - m[4] * m[11] * m[13] - m[8] * m[5] * m[15] + m[8] * m[7] * m[13] + m[12] * m[5] * m[11] - m[12] * m[7] * m[ 9];
	inv[12] = -m[4] * m[ 9] * m[14] + m[4] * m[10] * m[13] + m[8] * m[5] * m[14] - m[8] * m[6] * m[13] - m[12] * m[5] * m[10] + m[12] * m[6] * m[ 9];
	inv[ 1] = -m[1] * m[10] * m[15] + m[1] * m[11] * m[14] + m[9] * m[2] * m[15] - m[9] * m[3] * m[14] - m[13] * m[2] * m[11] + m[13] * m[3] * m[10];
	inv[ 5] =  m[0] * m[10] * m[15] - m[0] * m[11] * m[14] - m[8] * m[2] * m[15] + m[8] * m[3] * m[14] + m[12] * m[2] * m[11] - m[12] * m[3] * m[10];
	inv[ 9] = -m[0] * m[ 9] * m[15] + m[0] * m[11] * m[13] + m[8] * m[1] * m[15] - m[8] * m[3] * m[13] - m[12] * m[1] * m[11] + m[12] * m[3] * m[ 9];
	inv[13] =  m[0] * m[ 9] * m[14] - m[0] * m[10] * m[13] - m[8] * m[1] * m[14] + m[8] * m[2] * m[13] + m[12] * m[1] * m[10] - m[12] * m[2] * m[ 9];
	inv[ 2] =  m[1] * m[ 6] * m[15] - m[1] * m[ 7] * m[14] - m[5] * m[2] * m[15] + m[5] * m[3] * m[14] + m[13] * m[2] * m[ 7] - m[13] * m[3] * m[ 6];
	inv[ 6] = -m[0] * m[ 6] * m[15] + m[0] * m[ 7] * m[14] + m[4] * m[2] * m[15] - m[4] * m[3] * m[14] - m[12] * m[2] * m[ 7] + m[12] * m[3] * m[ 6];
	inv[10] =  m[0] * m[ 5] * m[15] - m[0] * m[ 7] * m[13] - m[4] * m[1] * m[15] + m[4] * m[3] * m[13] + m[12] * m[1] * m[ 7] - m[12] * m[3] * m[ 5];
	inv[14] = -m[0] * m[ 5] * m[14] + m[0] * m[ 6] * m[13] + m[4] * m[1] * m[14] - m[4] * m[2] * m[13] - m[12] * m[1] * m[ 6] + m[12] * m[2] * m[ 5];
	inv[ 3] = -m[1] * m[ 6] * m[11] + m[1] * m[ 7] * m[10] + m[5] * m[2] * m[11] - m[5] * m[3] * m[10] - m[ 9] * m[2] * m[ 7] + m[ 9] * m[3] * m[ 6];
	inv[ 7] =  m[0] * m[ 6] * m[11] - m[0] * m[ 7] * m[10] - m[4] * m[2] * m[11] + m[4] * m[3] * m[10] + m[ 8] * m[2] * m[ 7] - m[ 8] * m[3] * m[ 6];
	inv[11] = -m[0] * m[ 5] * m[11] + m[0] * m[ 7] * m[ 9] + m[4] * m[1] * m[11] - m[4] * m[3] * m[ 9] - m[ 8] * m[1] * m[ 7] + m[ 8] * m[3] * m[ 5];
	inv[15] =  m[0] * m[ 5] * m[10] - m[0] * m[ 6] * m[ 9] - m[4] * m[1] * m[10] + m[4] * m[2] * m[ 9] + m[ 8] * m[1] * m[ 6] - m[ 8] * m[2] * m[ 5];
	float det = m[0] * inv[0] + m[1] * inv[4] + m[2] * inv[8] + m[3] * inv[12];
	float rcp_det = 1.0f / det;
	for(uint32_t i = 0; i != 16; ++i)
		inv[i] = inv[i] * rcp_det;
}

//! Cheap and ok-ish random number generator
static inline uint32_t wang_random_number(uint32_t seed) {
	seed = (seed ^ 61) ^ (seed >> 16);
	seed *= 9;
	seed = seed ^ (seed >> 4);
	seed *= 0x27d4eb2d;
	seed = seed ^ (seed >> 15);
	return seed;
}


//! Little helper for half_to_float() to modify floats bit by bit
typedef union float32_union_u {
	uint32_t u;
	float f;
} float32_union_t;

/*! Converts a half-precision float (given as an integer with same binary
	representation) into a single-precision float with identical value.
	Originally half_to_float_fast5() as proposed by Fabian Giesen, see:
	https://fgiesen.wordpress.com/2012/03/28/half-to-float-done-quic/ */
static inline float half_to_float(uint16_t half) {
	static const float32_union_t magic = { (254 - 15) << 23 };
	static const float32_union_t was_infnan = { (127 + 16) << 23 };
	float32_union_t o;
	// Copy exponent and mantissa bits
	o.u = (half & 0x7fff) << 13;
	// Make adjustments to the exponent
	o.f *= magic.f;
	// Make sure that inf/NaN survive
	if (o.f >= was_infnan.f)
		o.u |= 255 << 23;
	// Copy the sign bit
	o.u |= (half & 0x8000) << 16;
	return o.f;
}


//! Returns the greatest common divisor of the given two integers
static inline uint64_t greatest_common_divisor(uint64_t a, uint64_t b) {
	// This is the Euclidean algorithm
	while (b != 0) {
		uint64_t t = b;
		b = a % b;
		a = t;
	}
	return a;
}

//! Returns the least common multiple of the given two positive integers
static inline uint64_t least_common_multiple(uint64_t a, uint64_t b) {
	return a * (b / greatest_common_divisor(a, b));
}

//! Returns the string in format H:mm:ss from elapsed time
static inline void get_time_str(char *s, float elapsedTime)
{
	int hours, mins, secs;

	hours = (int)floor(elapsedTime / 3600);
	mins = (int)floor((elapsedTime - hours * 3600) / 60);
	secs = (int)floor(elapsedTime - hours * 3600 - mins * 60);

	s[0] = 0;

	if (elapsedTime >= 60)
	{
		if (hours > 0)
			sprintf(s, "%s%dh", s, hours);
		if (mins > 0)
		{
			if (hours > 0)
				strcat(s, " ");
			sprintf(s, "%s%dm %ds", s, mins, secs);
		}
		else if (secs > 0)
		{
			if (hours > 0)
				strcat(s, " ");
			sprintf(s, "%s%ds", s, secs);
		}
	}
	else
	{
		sprintf(s, "%.1fs", elapsedTime);
	}
}

#define gigo (1000.0f * 1000.0f * 1000.0f)
#define mego (1000.0f * 1000.0f)

//! Returns string with mega, giga, kilo from size variable (file size, triangles, etc.)
static inline void convert_mega_giga(const float num, float *conv_num, char *kb_mega_giga)
{
	*conv_num = num;
	*kb_mega_giga = '\0';
	if (num >= gigo)
	{
		*kb_mega_giga = 'G';
		*conv_num = num / gigo;
	}
	else if (num >= mego)
	{
		*kb_mega_giga = 'm';
		*conv_num = num / mego;
	}
	else if (num >= 1000.0f)
	{
		*kb_mega_giga = 'k';
		*conv_num = num / 1000.0f;
	}
}
